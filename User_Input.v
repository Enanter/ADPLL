
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module User_Input(

	//////////// CLOCK //////////
	input 		          		CLOCK_50_B5B,

	//////////// KEY //////////
	input 		          		CPU_RESET_n,
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	//////////// GPIO GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO,
	output 			 [31:0]     Control_Signal
);


//=======================================================
//  REG/WIRE declarations
//=======================================================
	reg [31:0] Control_SignalT;
	reg [6:0] Dec_1;
	reg [6:0] Dec_2;
	reg [8:0] Whole_1;
	reg [8:0] Whole_2;
	reg [7:0] Display;

//=======================================================
//  Structural coding
//=======================================================

// assign 7-segment display outputs based on the current value
Decoder Unit1 (Display % 10,HEX0);
Decoder Unit2 ((Display/10)%10,HEX1);
// assign 7-segment display outputs based on the current value
assign Control_Signal = Control_SignalT;
//Make slow clock
reg [31:0] counter = 0;
reg slow_clock;
localparam CLOCK_DIVIDER = 5000000; // 5 million
always @(posedge CLOCK_50_B5B) begin
    if (counter == CLOCK_DIVIDER) begin
        slow_clock <= ~slow_clock; // invert the slow clock signal every 50 cycles
        counter <= 0;
    end else begin
        counter <= counter + 1;
    end
end

assign CLOCK_1MHz = slow_clock;
  // clocked process to update value based on KEY inputs
  always @(posedge slow_clock) begin
	case (SW[9:8])
		2'b00:begin
			Display = Whole_1;
			if (!CPU_RESET_n) begin
     				// reset value to 0 on CPU reset
      				Whole_1 <= 8'd0;
    			end else begin
     				 // increment value on KEY[0] press
      				if (!KEY[0]) begin
						Whole_1 <= (Whole_1 == 99) ? 8'd0 : Whole_1 + 1;
      				end
      			// decrement value on KEY[1] press
      				else if (!KEY[1]) begin
							Whole_1 <= (Whole_1 == 0) ? 8'd99 : Whole_1 - 1;
      				end
    			end
		end
		2'b01:begin
			Display = Dec_1;
			if (!CPU_RESET_n) begin
     				// reset value to 0 on CPU reset
      				Dec_1 <= 7'd0;
    			end else begin
     				 // increment value on KEY[0] press
      				if (!KEY[0]) begin
							Dec_1 <= (Dec_1 == 99) ? 8'd0 : Dec_1 + 1;
      				end
      			// decrement value on KEY[1] press
      				else if (!KEY[1]) begin
							Dec_1 <= (Dec_1 == 0) ? 8'd99 : Dec_1 - 1;
      				end
    			end
		end
		2'b10:begin
			 Display = Whole_2;
			if (!CPU_RESET_n) begin
     				// reset value to 0 on CPU reset
      				Whole_2 <= 8'd0;
    			end else begin
     				 // increment value on KEY[0] press
      				if (!KEY[0]) begin
							Whole_2 <= (Whole_2 == 99) ? 8'd0 : Whole_2 + 1;
      				end
      			// decrement value on KEY[1] press
      				else if (!KEY[1]) begin
							Whole_2 <= (Whole_2 == 0) ? 8'd99 : Whole_2 - 1;
      				end
    			end

		end
		2'b11:begin
			Display = Dec_2;
			if (!CPU_RESET_n) begin
     				// reset value to 0 on CPU reset
      				Dec_2 <= 7'd0;
    			end else begin
     				 // increment value on KEY[0] press
      				if (!KEY[0]) begin
							Dec_2 <= (Dec_2 == 99) ? 8'd0 : Dec_2 + 1;
      				end
      			// decrement value on KEY[1] press
      				else if (!KEY[1]) begin
							Dec_2 <= (Dec_2 == 0) ? 8'd99 : Dec_2 - 1;
      				end
    			end
		end
	endcase
//assign output control signal
Control_SignalT[6:0] = Dec_1;
Control_SignalT[15:7] = Whole_1;
Control_SignalT[22:16] = Dec_2;
Control_SignalT[31:23] = Whole_2;
  end

endmodule